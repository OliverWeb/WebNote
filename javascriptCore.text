1.数据的转换
	①x.toString(); 这里不能转换 null,undefined(不存在的数据,生命的变量为赋值);
	②String(x);一切都可以的;
2.var num Number(x);
		Number也可以转纯数字组成的字符串;
3.短路逻辑和三目运算;
4.编码和解码
	URI不允许出现多个字节;
	第一种:
		①发送方将多字节字符编码=>单字节字符
			var code=encodeURI(str);
		②接收方将单字节进行解码为原文
			var code=decodeURI(code);
	第二种:
		①var code=encodeURIComponent(str);
		②var  str=encodeURIComponent(code);
5.eval
		执行字符串的格式的程序;
		对象和数组;
6.hash数组的原理
	对象和数组的区别是什么?
7.错误处理:如果函数定义者,希望提醒调用者错误的使用了函数的时候
8.Function
		1.声明方式,声明的函数会被hoist;
		2.函数的直接量
			var 函数名=function(xxx){....}
		3.用new进行创建
			var 函数名=new Function("参数","参数","函数体")
9.重载:
	相同的函数名,不同的参数列表的多个函数,在调用时,根据传入参数的不同,执行不同的逻辑.
	何时使用:在一项任务中,根据不同的参数,选择不同的逻辑执行.
	减轻调用者负担.
	js中不支持,使用arguments对象,
		function fn(){
			if(argument.length==0){
				console.log();
			}else if(argument.length==1){
				console.log();
			}
		}
		fn(1,2)
	类数组对象:长的像数组的对象集合;
10.匿名函数
		创建后,不被任何人引用,不可重用,确定只使用一次函数
		优点(节约内存);
		①自调:函数定义后,立即就执行;
		②回调:将函数定义后,传给其他函数调用.
11.闭包
		(主要是函数的作用域没有释放造成的)
		(比一般函数占用的更过的内存,容易造成内存泄漏)
		重用局部变量,保护变量不受污染的机制
		局部变量:只能在函数内使用,不能灵活使用.
		全局变量:随处可以用,可以重复使用,变量容易被污染.
		3步:
			1.用外层函数将(变量和操作变量的函数进行包裹起来).
			2.外层函数将内层函数对象返回.
			3.调用外层函数,获得内层函数对象.
			
		应用过程中:
		1.先找受保护的变量,确定其中值(变量可能不是声明时候的初始值---看外层函数调用结束的值)
		2.找操作变量的函数:
			1.return fun
      2.可能直接给全局变量赋值;
12.函数作用域,有参数和没有参数,有参数,可以是使用全局变量,但不影响全局,没有参数是就是得去全局,并影响全局的变量;
13.面向对象
		:程序中先用对象描述现实中一个具体属性和功能;,在按照需要进行调用功能,操作属性.
		面向对象有三种,封装,继承,多态.
		封装:
			1.对象的直接量(单独创建一个对象)
				var obj={
						属性名:属性值,
						属性名:属性值,
						方法名:function(){
						....
						}
				}
				js的底层,一切对象都是hash数组;每个属性个方法其实都是hash数组中的元素;
			2.用new进行穿件
				1.先创建空对象,
					var obj=new Object()
					new 和()可以省略,
					obj.新属性=值;
					obj.新方法=function(){....}
					强调:js中的对象随时可添加新属性和方法.js底层是hash数组
			3.定义构造函数:
				constructor
				一类对象(统一函数)的对象;
				1.function 类型名(属性参数){
						this.属性名=属性值;
						this.方法名=function(){}
					}
				2.用new进行构造函数,传入属性值;
					var obj=new 类型名(属性值)
继承:
		继承是是可以节约内存的,然而,闭包会增加内存的消耗;
		只要多个子对象中包含相同的成员,就可以将相同的成员保存到子对象中一次,所有的子对象共同使用;
		原型对象:集中保存所有子对象共有成员的父级对象;
		原型对象不用创建,每个构造函数都自带一个原型对象;
		如何进行获得:
				1.构造函数.prototype
					子对象._proto_是内部属性;
					获取对象的父级对象:Object.getPrototypeOf(Obj)
					添加成员:
					构造函数添加新成员:构造函数.prototype.新成员=xxx;
				2.
						
						
				
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		